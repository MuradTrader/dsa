1. Введение в основные временные сложности
«Итак, начиная с этой лекции, мы разберём основные временные сложности алгоритмов.

В мире алгоритмов существует множество типов сложности.

Здесь мы сосредоточимся на самых распространённых.»

2. Список рассматриваемых сложностей
«Вот список сложностей, которые мы изучим в следующих лекциях:

Константная временная сложность (O(1)),

Линейная сложность (O(n)),

Логарифмическая сложность (O(log n)),

Квадратичная (O(n²)) и экспоненциальная (O(2ⁿ)) сложности.

Для каждой из них мы приведём реальные примеры, чтобы глубже понять их природу.»

3. Константная временная сложность (O(1))
«Начнём с первого типа — константной временной сложности (O(1)).

Это означает, что время выполнения алгоритма не зависит от размера входных данных.
Оно остаётся постоянным при любом вводе.»

3.1 Пример кода: multiplyNumbers(n)
«Рассмотрим простую функцию:

function multiplyNumbers(n) {
    return n * n;
}
Эта функция принимает число n и возвращает его квадрат.

Неважно, будет n = 5 или n = 4000 — количество операций всегда одно (умножение).

Проверим это:

Для n = 5: результат 25 (1 операция),

Для n = 4000: результат 16 000 000 (всё та же 1 операция).

Независимо от входного значения, сложность остаётся O(1)».

3.2 Пример из жизни: удаление случайной карты
«Представьте колоду карт.

Если я попрошу вас вытащить любую случайную карту, вам не нужно перебирать всю колоду.
Вы просто берёте верхнюю карту — это займёт постоянное время, независимо от размера колоды.

Даже если в колоде 10 или 1000 карт, сложность операции останется O(1)».

3.3 Графическая иллюстрация
«На графике:

Ось X: количество элементов (размер ввода),

Ось Y: количество операций.

Для константной сложности график — горизонтальная прямая, так как операции не зависят от размера данных.

График O(1)

Даже при 3 или 1000 элементах сложность остаётся O(1).

Это самый эффективный тип сложности — лучше O(1) не существует.

Запомните: «константная сложность» всегда означает **O(1)».

На этом графике мы позже добавим другие типы сложностей для сравнения.»

Итог:
Константная сложность — эталон эффективности. 
Её можно достичь, когда алгоритм выполняет фиксированное количество операций, независимо от входных данных. 
Примеры: доступ к элементу массива по индексу, вставка в начало связанного списка.