1. Введение в линейную временную сложность (O(n))
«Следующий тип временной сложности, который мы изучим, — O(n) (линейная временная сложность).

Здесь сложность алгоритма растёт прямо пропорционально размеру входных данных.

В идеале стоит проектировать алгоритмы с сложностью ниже O(n), но это не всегда возможно.»

2. Пример кода: printItems(n)
«Рассмотрим простую функцию:

function printItems(n) {
  for (let i = 0; i < n; i++) {
    console.log(i);
  }
}
Эта функция выводит в консоль числа от 0 до n-1.

При n = 3 выполнится 3 операции (вывод 0, 1, 2).

При n = 10 — 10 операций (0–9).

При n = 100 — 100 операций.

Как видите, количество операций линейно зависит от n. Это классический пример O(n).»

3. Пример из жизни: поиск карты в колоде
«Вернёмся к аналогии с колодой карт.

Представьте, что вам нужно найти десятку червей.

В худшем случае карта будет последней в колоде.

Вам придётся перебрать все карты (например, 52 штуки).

Если колода увеличится до 100 карт, время поиска вырастет пропорционально.

Таким образом, поиск элемента в неупорядоченном наборе данных имеет сложность O(n), где n — количество элементов.»

4. Графическая иллюстрация
«На графике:

Ось X: количество элементов (n),

Ось Y: количество операций.

Для O(n) график — прямая линия, так как операции растут пропорционально n.

График O(n)

При 10 элементах — 10 операций,

При 100 элементах — 100 операций.

Линейная сложность — базовый, но важный эталон. Она часто встречается в алгоритмах с циклами, где каждый элемент обрабатывается один раз.»

Итог:
Линейная сложность O(n) — «золотая середина» между эффективностью и реалистичностью. Примеры:

Поиск элемента в неотсортированном массиве,

Обход списка,

Фильтрация данных.

Старайтесь оптимизировать алгоритмы до O(n) или ниже, где это возможно.